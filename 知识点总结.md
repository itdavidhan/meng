# 改写if else  

### 1.switch  
* 优点：
    - 结构更清晰
    - 提高程序效率
* 缺点：只能处理字符或者数字类型的变量，不如if else灵活  
* 示例：
    ```
    if(type == 1) {
      n = 'a';
    } else if(type == 2) {
      n = 'b';
    } else {
      n = 'c';
    }
    switch(type) {
      case 1:
        n = 'a';
        break;
      case 2:
        n = 'b';
        break;
      default:
        n = 'c';
        break;
    }
    ```

### 2.三元运算符  
* 优点：代码简化，更加清爽
* 缺点：复杂的三元运算符可读性较差，需友好注释  
* 示例：
    ```
    if(n>0) {
      a = 'b';
    } else {
      a = 'c';
    }
    a = n>0 ? 'b' : 'c';
    ```

### 3.逻辑判断 and(&&) or(||)  
* 原理：利用逻辑判断的短路运算来实现
* 优点：代码简化，更加清爽
* 缺点：适用于简单判断逻辑，复杂的判断运算可读性较差，需友好注释  
* 示例：
    ```
    if(cb) cb();
    cb && cb();
    ```

### 4.look-up  
* 原理：数据与业务逻辑分离
* 优点：便于维护，需求变化时只需修改数据，不必修改业务逻辑
* 缺点：只适用于if判断逻辑统一的情形
* 示例：
    ```
    function showGrade1(grade) {
      if(grade >= 100) {
        return '满分';
      } else if(grade >= 90) {
        return '优秀';
      } else if(grade >= 80) {
        return '良好';
      } else if(grade >= 60) {
        return '及格';
      } else {
        return '不及格';
      }
    }
    function showGrade2(grade) { 
      let gradeForLevel = [100, 90, 80, 60];
      let levelText = ['满分','优秀','良好','及格','不及格']; 
      gradeForLevel.forEach((item, index) => {
        if(grade >= item) {
          return levelText[index];
        }
      }); 
      return levelText[levelText.length-1]; 
    }
    ```
### 5.策略模式
* 原理：定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来
* 优点：
    - 有效避免多重条件选择语句
    - 提供了对外开放封装原则的完美支持，将方法封装在独立的strategy中，使得它们易于切换、易于理解、易于扩展
    - 便于复用